#' Create fractals of a noise or pattern
#'
#' This function allows you to create fractals of a given noise or pattern
#' generator by calculating it repeatedly at changing frequency and combining
#' the results based on a fractal function.
#'
#' @param noise The noise function to create a fractal from. Must have a
#' `frequency` argument.
#' @param fractal The fractal function to combine the generated values with. Can
#' be one of the provided ones or a self-made function. If created by hand it
#' must have the following arguments:
#'
#' - `base`: The current noise values
#' - `new`: The new noise values to combine with `base`
#' - `strength`: The value from `gain` corresponding to the index of `new`
#' - `octave`: The index of `new`
#'
#' And must return a numeric vector of the same length as `new`
#' @param octaves The number of generated values to combine
#' @param gain The intensity of the generated values at each octave. The
#' interpretation of this is up to the fractal function. Usually the intensity
#' will gradually fall as the frequency increases. Can either be a vector of
#' values or a (lambda) function that returns a new value based on the prior,
#' e.g. `~ . / 2`. The default is often a good starting point though e.g.
#' [ridged()] fractal has been designed with a special gain function.
#' @param frequency The frequency to use at each octave. Can either be a vector
#' of values or a function that returns a new value based on the prior. See
#' `gain`.
#' @param seed A seed for the noise generator. Will be expanded to the number of
#' octaves so each gets a unique seed.
#' @param ... arguments to pass on to `generator`
#' @param fractal_args Additional arguments to `fractal` as a named list
#' @param gain_init,freq_init The gain and frequency for the first octave if
#' `gain` and/or `frequency` are given as a function.
#'
#' @seealso ambient comes with a range of build in fractal functions: [fbm()],
#' [billow()], [ridged()], [clamped()]
#'
#' @export
#'
#' @examples
#' grid <- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
#'
#' # When noise is generated by it's own it doesn't have fractal properties
#' grid$clean_perlin <- gen_perlin(grid$x, grid$y)
#' plot(grid, clean_perlin)
#'
#' # Use fracture to apply a fractal algorithm to the noise
#' grid$fractal_perlin <- fracture(gen_perlin, fbm, octaves = 8,
#'                                 x = grid$x, y = grid$y)
#' plot(grid, fractal_perlin)
#'
from typing import Callable
from functools import reduce
import numpy as np


class Fbm:
    def __call__(self, base, new, strength):
        return base + new * strength


class Clamped(Fbm):
    def __call__(self, base, new, strength, min = 0, max = np.inf):
        new = np.clip(new, min, max)
        return super(Clamped, self)(base, new, strength)


class Billow(Fbm):
    def finalize(self, x):
        return x + 0.5

    def __call__(self, base, new, strength):
        new = (2 * np.abs(new) - 1)
        return super(Billow, self)(base, new, strength)


class Ridged(Fbm):
    def finalize(self, x):
        return x * 1.25 - 1

    def __call__(self, base, new, strength, octave, offset = 1, gain = 2):
        signal = np.power((offset - np.abs(new)), 2)
        if octave ==1 :
            old_noise = 1
        signal = signal * old_noise
        old_noise = signal * gain
        return super(Ridged, self)(base, signal, strength)

def fracture(noise_func:Callable,
            fractal_function:Callable,
            octaves:int,
            gain:Callable,
            frequency:Callable,
            seed:int, gain_init, freq_init):

    gain = reduce(gain, range(octaves),initial=gain_init)
    frequency = reduce(frequency, range(octaves),initial=freq_init)
    seeds = np.random.randint(size=octaves)

  frac <- 0
  for (i in seq_len(octaves)) {
    frac <- do.call(
      fractal,
      c(
        list(
          base = frac,
          new = noise(..., frequency = frequency[i], seed = seed[i]),
          strength = gain[i],
          octave = i
        ),
        fractal_args
      )
    )
  }
  finalise(frac, fractal)
}

finalise <- function(noise, fractal) {
  fin <- attr(fractal, 'finalise')
  if (is.null(fin)) {
    noise
  } else {
    fin(noise)
  }
}